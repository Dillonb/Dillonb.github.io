<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://dillonbeliveau.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://dillonbeliveau.com/" rel="alternate" type="text/html" /><updated>2020-07-03T11:54:18-04:00</updated><id>https://dillonbeliveau.com/feed.xml</id><title type="html">Dillon Beliveau</title><subtitle>Blog of a software engineer in Vermont.</subtitle><entry><title type="html">GameBoy Advance Cartridge Backup Storage</title><link href="https://dillonbeliveau.com/2020/06/05/GBA-FLASH.html" rel="alternate" type="text/html" title="GameBoy Advance Cartridge Backup Storage" /><published>2020-06-05T00:00:00-04:00</published><updated>2020-06-05T00:00:00-04:00</updated><id>https://dillonbeliveau.com/2020/06/05/GBA-FLASH</id><content type="html" xml:base="https://dillonbeliveau.com/2020/06/05/GBA-FLASH.html">&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;I&amp;#8217;m writing this post because I had some difficulty understanding the wonderful &lt;a href=&quot;http://problemkaputt.de/gbatek.htm#gbacartbackupids&quot;&gt;GBATek&lt;/a&gt;&amp;#8217;s documentation on the different backup storage types GameBoy Advance games could use while working on my emulator. Hopefully, this information will be useful to someone.&lt;/p&gt;
&lt;p&gt;As the GBA did not have any internal persistant storage like modern consoles do, if a game developer wanted to implement a save feature in their game, they had to package storage directly inside the cartridge.&lt;/p&gt;
&lt;p&gt;The cartridges could ship with several different types of backup storage. These included &lt;a href=&quot;https://en.wikipedia.org/wiki/Static_random-access_memory&quot;&gt;SRAM&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;Flash&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/EEPROM&quot;&gt;EEPROM&lt;/a&gt;. In general, flash can be considered a type of EEPROM, but for the purposes of this article and the GBA, they are two separate categories, because they are read and written with two separate protocols.&lt;/p&gt;
&lt;h1&gt;What type of backup does my cartridge use?&lt;/h1&gt;
&lt;p&gt;Standard GBA cartridge dumps will (usually) include the type of backup storage they use as text somewhere in the file. This is a &lt;i&gt;good enough&lt;/i&gt; way of determining the type.&lt;/p&gt;
&lt;p&gt;To identify the cartridge&amp;#8217;s type, search the entire ROM for one of the following strings in this table. This will work &lt;i&gt;most of the time&lt;/i&gt;. There are a couple games where it won&amp;#8217;t, however. For better accuracy, you should use the regular expression in the Regex column, and for best accuracy, you should keep a game database that you manually update to match save types to games.&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;String&lt;/th&gt;&lt;th&gt;Regex&lt;/th&gt;&lt;th&gt;Backup Type&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;EEPROM_&lt;/td&gt;&lt;td&gt;EEPROM_V\d\d\d&lt;/td&gt;&lt;td&gt;Cartridge uses EEPROM. Either 512 bytes or 8KB&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;SRAM_&lt;/td&gt;&lt;td&gt;SRAM_V\d\d\d&lt;/td&gt;&lt;td&gt;Cartridge uses SRAM&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;FLASH_&lt;/td&gt;&lt;td&gt;FLASH_V\d\d\d&lt;/td&gt;&lt;td&gt;Flash 64 kilobytes / 512 kilobits&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;FLASH512_&lt;/td&gt;&lt;td&gt;FLASH512_V\d\d\d&lt;/td&gt;&lt;td&gt;Flash 64 kilobytes / 512 kilobits&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;FLASH1M_&lt;/td&gt;&lt;td&gt;FLASH1M_V\d\d\d&lt;/td&gt;&lt;td&gt;Flash 128 kilobytes / 1 megabit&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;See &lt;a href=&quot;http://problemkaputt.de/gbatek.htm#gbacartbackupids&quot;&gt;GBATek&lt;/a&gt; for more details.&lt;/p&gt;
&lt;p&gt;It sounds hacky, but that&amp;#8217;s because it is.&lt;/p&gt;
&lt;h1&gt;SRAM&lt;/h1&gt;
&lt;p&gt;SRAM is by far the simplest type of backup storage, both for emulator developers and game developers. It&amp;#8217;s simply another type of RAM, just one that happens to be on the cartridge instead of internal to the system. Unfortunately, it&amp;#8217;s volatile, which means that if it loses power, your save data is gone. Cartridges that used SRAM included a built-in backup battery to keep the RAM powered, and your precious high scores in Pokémon Pinball: Ruby and Sapphire safe.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m not going to go into too much detail here, as this is just RAM accessed like any other RAM, it just happens to be in the cartridge address space 0xE000000 through 0xE007FFF. Making this persistent in an emulator is as easy as persisting this space to disk, using either mmap or detecting changes and writing out a save.&lt;/p&gt;
&lt;h1&gt;Flash&lt;/h1&gt;
&lt;h2&gt;Introduction to Flash&lt;/h2&gt;
&lt;p&gt;See &lt;a href=&quot;http://problemkaputt.de/gbatek.htm#gbacartbackupflashrom&quot;&gt;the section in GBATek.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Flash memory in GBA carts has the advantage of being non-volatile, meaning it doesn&amp;#8217;t need a battery in the cartridge to keep your progress safe. The chips did have a limited number of write cycles, though this isn&amp;#8217;t something an emulator developer needs to worry about.&lt;/p&gt;
&lt;p&gt;There were several chips that Nintendo used for Flash, all made by different manufacturers. GBATek lists them all.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Important:&lt;/b&gt; You do NOT need to simulate all the different chips! When a developer shipped their code off to Nintendo to be put in a cartridge, they did &lt;b&gt;NOT&lt;/b&gt; know what type of chip it would be manufactured with! Different production runs of the same game could even use different manufacturer&amp;#8217;s chips! As a consequence of this, all games should support &lt;i&gt;all Flash types.&lt;/i&gt; I&amp;#8217;m sure there are exceptions, but this means that your emulator need only support one type. I chose Sanyo for mine, as you can see below in the &amp;#8220;Stubbing Flash&amp;#8221; section.&lt;/p&gt;
&lt;p&gt;As a downside, accessing it is significantly more complicated than for SRAM. The main loop the game will use is made up of sending the chip commands, and taking actions.&lt;/p&gt;
&lt;p&gt;Because the commands and actions are taken separately, it can (and should) be implemented as a state machine. This means you&amp;#8217;ll need to hold state somewhere of what the Flash chip is currently doing, and treat reads and writes differently based on this state.&lt;/p&gt;
&lt;h2&gt;Sending Flash commands&lt;/h2&gt;
&lt;p&gt;Commands are sent by 3 separate, sequential 8-bit writes to memory.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;0xAA to 0xE005555&lt;/li&gt;
  &lt;li&gt;0x55 to 0xE002AAA&lt;/li&gt;
  &lt;li&gt;The byte representing the command to 0xE005555&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can keep track of this by switching your state variable from READY to something like CMD_1 to track the 0xAA write, CMD_2 to track the 0x55 write, and then to a state specified by the command on the third write.&lt;/p&gt;
&lt;h3&gt;Relevant commands&lt;/h3&gt;
&lt;p&gt;Here&amp;#8217;s a table of all the relevant commands you&amp;#8217;ll need to implement. See below for more details. Note: I have omitted Atmel-specific commands. These are the only devices that differ in protocol used to communicate with them, and Nintendo supposedly stopped using them towards the end of the GBA&amp;#8217;s lifetime. As far as I know, there are no games that require them. I&amp;#8217;ve also omitted the Macronix-only &amp;#8220;terminate command after timeout&amp;#8221; command.&lt;/p&gt;
&lt;p&gt;Unless specified, the chip returns to &amp;#8220;ready&amp;#8221; state after every command.&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;8-bit write to 0xE005555&lt;/th&gt;&lt;th&gt;Command&lt;/th&gt;&lt;th&gt;Notes&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0x90&lt;/td&gt;&lt;td&gt;Enter &amp;#8220;Chip identification mode&amp;#8221;&lt;/td&gt;&lt;td&gt;In chip identification mode, the data in 0x0E000000 and 0x0E000001 are replaced by the flash chip&amp;#8217;s manufacturer and device ID, as specified in the &amp;#8220;Stubbing Flash&amp;#8221; section below.&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0xF0&lt;/td&gt;&lt;td&gt;Exit &amp;#8220;Chip identification mode&amp;#8221;&lt;/td&gt;&lt;td&gt;Return the chip back to READY mode.&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0x80&lt;/td&gt;&lt;td&gt;Prepare to receive erase command&lt;/td&gt;&lt;td&gt;Next command must be one of the following two erase commands.&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0x10&lt;/td&gt;&lt;td&gt;Erase entire chip&lt;/td&gt;&lt;td&gt;MUST be preceded by a &amp;#8216;prepare to receive erase command&amp;#8217;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0x30&lt;/td&gt;&lt;td&gt;Erase 4 kilobyte sector&lt;/td&gt;&lt;td&gt;MUST be preceded by a &amp;#8216;prepare to receive erase command.&amp;#8217; The address of the third write is also different than the other commands, and meaningful. See below. Only available on non-Atmel chips.&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0xA0&lt;/td&gt;&lt;td&gt;Prepare to write single data byte&lt;/td&gt;&lt;td&gt;Next write must be a write of a single byte. Only available on non-Atmel chips.&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0xB0&lt;/td&gt;&lt;td&gt;Set memory bank&lt;/td&gt;&lt;td&gt;Only works on 128KB flash devices, which are represented as two 64KB banks. 64KB flash devices don&amp;#8217;t support bank switching, for reasons that should be obvious.&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;h3&gt;0x90 Enter Chip Identification mode&lt;/h3&gt;
&lt;p&gt;In chip identification mode, the data in 0x0E000000 and 0x0E000001 are replaced by the flash chip&amp;#8217;s manufacturer and device ID, as specified in the &amp;#8220;Stubbing Flash&amp;#8221; section below.
  The chip stays in this mode until the &amp;#8220;exit chip identification mode&amp;#8221; command is issued.&lt;/p&gt;
&lt;p&gt;As far as I know, the game can issue other commands while in this mode, so for that purpose it should be treated the same as &amp;#8220;ready&amp;#8221; mode.&lt;/p&gt;
&lt;h3&gt;0xF0 Exit Chip Identification mode&lt;/h3&gt;
&lt;p&gt;When this command is issued, the device returns to &amp;#8220;ready&amp;#8221; mode, and reads from the first two addresses are normal again.&lt;/p&gt;
&lt;h3&gt;0x80 Prepare to receive erase command&lt;/h3&gt;
&lt;p&gt;This command must be issued before issuing one of the two erase commands specified below. In fact, the next command &lt;i&gt;must&lt;/i&gt; be an erase command.&lt;/p&gt;
&lt;h3&gt;0x10 Erase entire chip&lt;/h3&gt;
&lt;p&gt;Erases the entire chip. Note that this is not done with zeroes, but every byte in memory will equal 0xFF when done. This normally takes a decent amount of time, but it&amp;#8217;s probably fine to do it instantly. The game will wait until a read from 0x0E000000 returns 0xFF, so if you want to go for some kind of cycle-accuracy here, make sure to erase that byte last.&lt;/p&gt;
&lt;h3&gt;0x30 Erase 4KB sector&lt;/h3&gt;
&lt;p&gt;Instead of the standard 0xE005555, 0xE002AAA, 0xE005555 sequence that every other command uses, this one is a little special.&lt;/p&gt;
&lt;p&gt;The first two writes happen normally. However, instead of the third write being to 0xE005555, the game will write 0x30 to 0x0E00n000, where n is a number representing the page to be erased.&lt;/p&gt;
&lt;p&gt;For example, if the game writes 0x30 to 0x0E005000, then all bytes from 0x0E005000 through 0x0E005FFF should be erased, and replaced with 0xFF (same value as in the above command. Flash chips erase to 0xFF, not to 0x00.)&lt;/p&gt;
&lt;p&gt;The game will then wait until the value at address 0x0E00n000 reads 0xFF. Again, if you&amp;#8217;re trying for cycle accuracy here and not doing this all at once, erase this last.&lt;/p&gt;
&lt;h3&gt;0xA0 Prepare to write single data byte&lt;/h3&gt;
&lt;p&gt;After this command, the game should issue one write to a flash address between 0x0E000000 and 0x0E00FFFF. You can emulate this as happening instantly, but games will wait until that value appears before continuing.&lt;/p&gt;
&lt;h3&gt;0xB0 Set memory bank&lt;/h3&gt;
&lt;p&gt;This allows 128KB flash chips to expose their full size to the game, even though the address bus they&amp;#8217;re connected to only supports 64KB of address space.
  After issuing this command, the game will write either the value 0 or 1 to the address 0x0E000000. This determines which bank ALL commands that access the memory use.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Erase 4KB sector&lt;/li&gt;
  &lt;li&gt;Write single data byte&lt;/li&gt;
  &lt;li&gt;Data reads&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Special: Terminate write/erase command&lt;/h3&gt;
&lt;p&gt;When a game determines it&amp;#8217;s been waiting long enough for a write to happen, it can terminate the wait period by writing 0xF0 to 0x0E005555. This is not part of any command sequence, but occurs as a single write. When this write happens after a write command has been issued and completed, it&amp;#8217;s safe to return the chip to Ready mode. If this write occurs while the chip is already in ready mode, it can be ignored.&lt;/p&gt;
&lt;h2&gt;Reading data out of Flash&lt;/h2&gt;
&lt;p&gt;This part is easy. A read from an address in Flash space reads that index in the flash backup. Any address between 0x0E000000 - 0x0E00FFFF will work. For 128KB devices, this takes into account the bank-switching mechanism. Note that when the chip is in &amp;#8220;chip identification mode,&amp;#8221; reads from the first and second address will return different data.&lt;/p&gt;
&lt;h2&gt;Note: Stubbing Flash&lt;/h2&gt;
&lt;p&gt;If you want to test games like Pokémon Emerald in your emulator, but aren&amp;#8217;t quite ready for the &lt;i&gt;full experience&lt;/i&gt; of implementing Flash, there&amp;#8217;s a quick and easy way to stub it. Obviously, saving the game won&amp;#8217;t work, but, assuming nothing else is wrong, you&amp;#8217;ll be able to go in-game.&lt;/p&gt;
&lt;p&gt;In your memory bus, simply return the following values on 8-bit reads to the specified addresses.&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;8-bit read address&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;Meaning&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0x0E000000&lt;/td&gt;&lt;td&gt;0x62&lt;/td&gt;&lt;td&gt;Sanyo manufacturer ID&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;0x0E000001&lt;/td&gt;&lt;td&gt;0x13&lt;/td&gt;&lt;td&gt;Sanyo device ID&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;And with that, you should have enough information to implement flash backups in your emulator.&lt;/p&gt;
&lt;h1&gt;EEPROM&lt;/h1&gt;
&lt;p&gt;Coming soon!&lt;/p&gt;</content><author><name></name></author><category term="emudev emulators emulation game boy advance gba flash eeprom sram backup" /></entry><entry><title type="html">AWS ECS IAM Roles: Demystified</title><link href="https://dillonbeliveau.com/2018/12/08/aws-ecs-iam-roles-demystified.html" rel="alternate" type="text/html" title="AWS ECS IAM Roles: Demystified" /><published>2018-12-08T00:00:00-05:00</published><updated>2018-12-08T00:00:00-05:00</updated><id>https://dillonbeliveau.com/2018/12/08/aws-ecs-iam-roles-demystified</id><content type="html" xml:base="https://dillonbeliveau.com/2018/12/08/aws-ecs-iam-roles-demystified.html">&lt;p&gt;To run tasks in ECS, up to four different roles are required. Which ones you need depends on a variety of factors. Probably the most frustrating thing for me when getting started with ECS was confusion around which of these roles needed what permissions, the purpose of each of them, how to create them, what components of the system used them, and where to configure them. This post does not attempt to be a complete introduction or reference to ECS in general, just a source to hopefully clear up confusion around IAM and ECS.&lt;/p&gt;
&lt;h2&gt;Role Types&lt;/h2&gt;
&lt;h3&gt;Host Role&lt;/h3&gt;
&lt;p&gt;When running ECS on EC2, the EC2 instances hosting the containers need a role. This role gives them permission to, among other things, pull images from ECR, manage tasks in the ECS API, and put logs into cloudwatch.&lt;/p&gt;
&lt;h3&gt;Task Execution Role&lt;/h3&gt;
&lt;p&gt;When running in Fargate, there are no EC2 instances hosting your containers, so these permissions have to go somewhere. This is called a &lt;i&gt;Task Execution Role.&lt;/i&gt; It gives the Fargate service the same permissions the EC2 instance would need. This role is &lt;i&gt;not&lt;/i&gt; required when running tasks on EC2 backed ECS.&lt;/p&gt;
&lt;h3&gt;ECS Service-Linked Role&lt;/h3&gt;
&lt;p&gt;This is a role used by the ECS service itself to perform functions such as managing load balancer configuration, doing service discovery, as well as attaching network interfaces when using the `awsvpc` network mode.
  There is only one of these per account.&lt;/p&gt;
&lt;h3&gt;ECS Task Role (or Container Role)&lt;/h3&gt;
&lt;p&gt;Not to be confused with the Task &lt;i&gt;Execution&lt;/i&gt; Role, the Task Role is used when code running inside the container needs access to AWS resources. This is equivalent to the instance profile if the code was running directly on an EC2 instance.&lt;/p&gt;
&lt;h2&gt;Creating the Required Roles in an ALKS-Controlled Account&lt;/h2&gt;
&lt;p&gt;At my company, we use a tool called ALKS to manage access to and permissions in our AWS accounts. We open sourced a &lt;a href=&quot;https://github.com/Cox-Automotive/terraform-provider-alks&quot;&gt;Terraform provider&lt;/a&gt; for it, and that&amp;#8217;s what my examples will be using. If needed, find another source for how to create the roles and use these examples for information on what policies to attach.&lt;/p&gt;
&lt;h3&gt;Host Role&lt;/h3&gt;
&lt;p&gt;This will be a standard IAM Role. First create the role itself:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;terraform&quot;&gt;
resource &amp;quot;alks_iamrole&amp;quot; &amp;quot;ecs_host&amp;quot; {
  name                     = &amp;quot;ecs-host-role&amp;quot;
  type                     = &amp;quot;Amazon EC2&amp;quot;
  include_default_policies = false
}
&lt;/pre&gt;
&lt;p&gt;If you use multiple clusters, you can prefix it with the name of your cluster, creating a `flume-ecs-host-role` for example.&lt;/p&gt;
&lt;p&gt;Then attach the required policy:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;terraform&quot;&gt;
resource &amp;quot;aws_iam_role_policy_attachment&amp;quot; &amp;quot;ecs_host_ecs_attachment&amp;quot; {
  role       = &amp;quot;${alks_iamrole.ecs_host.name}&amp;quot;
  policy_arn = &amp;quot;arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role&amp;quot;
}
&lt;/pre&gt;
&lt;p&gt;This is an AWS Managed policy, so there&amp;#8217;s no need to create it.&lt;/p&gt;
&lt;h3&gt;Task Execution Role&lt;/h3&gt;
&lt;p&gt;Create a role with the type &amp;#8220;Amazon EC2 Container Service Task Role&amp;#8221; and attach the AWS provided policy to it.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;terraform&quot;&gt;
resource &amp;quot;alks_iamrole&amp;quot; &amp;quot;task_execution_role&amp;quot; {
  name                     = &amp;quot;ecsTaskExecutionRole&amp;quot;
  type                     = &amp;quot;Amazon EC2 Container Service Task Role&amp;quot;
  include_default_policies = false
}

resource &amp;quot;aws_iam_role_policy_attachment&amp;quot; &amp;quot;task_execution_attachment&amp;quot; {
  policy_arn = &amp;quot;arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy&amp;quot; // AWS provided policy
  role       = &amp;quot;${alks_iamrole.task_execution_role.name}&amp;quot;
}
&lt;/pre&gt;
&lt;h3&gt;Service Linked Role&lt;/h3&gt;
&lt;p&gt;Normally, this role would be created automatically the first time it&amp;#8217;s needed. However, if your account is as locked down as my account at work is, you&amp;#8217;ll need to create it manually from a privileged login.&lt;/p&gt;
&lt;p&gt;Provide the AWS cli with credentials that have permission to create roles, and run:&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;bash&quot;&gt;
$ aws iam create-service-linked-role --aws-service-name ecs.amazonaws.com
&lt;/pre&gt;
&lt;p&gt;This only needs to be run once per account. Once the role is created you&amp;#8217;ll never have to worry about it again, and you won&amp;#8217;t even have to refer to it in any Terraform or other configuration. The ECS service will just use it if it exists.&lt;/p&gt;
&lt;h3&gt;Task Role&lt;/h3&gt;
&lt;p&gt;Create a role as normal, but give it the type of &amp;#8220;Amazon EC2 Container Service Task Role&amp;#8221;&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;terraform&quot;&gt;
resource &amp;quot;alks_iamrole&amp;quot; &amp;quot;config_services_container&amp;quot; {
  name                     = &amp;quot;application-name-container-role&amp;quot;
  type                     = &amp;quot;Amazon EC2 Container Service Task Role&amp;quot;
  include_default_policies = false
} 
&lt;/pre&gt;
&lt;p&gt;There are no required attachments or other settings here. Just name it something that makes sense and attach the policies you need to it.&lt;/p&gt;
&lt;h3&gt;What about through the UI?&lt;/h3&gt;
&lt;p&gt;While it&amp;#8217;s certainly possible to do all this through the UI, I highly recommend using a tool like Terraform to manage configuration and permissions.&lt;/p&gt;
&lt;p&gt;Create the roles with the correct &amp;#8220;type&amp;#8221; in the UI, and attach the required policies to them. You should use Terraform though.&lt;/p&gt;
&lt;h2&gt;Terraforming Services and Tasks&lt;/h2&gt;
&lt;p&gt;Here&amp;#8217;s a quick overview of which roles go where when terraforming resources. The Terraform documentation is very good for the properties I&amp;#8217;m leaving out. See docs for &lt;a href=&quot;https://www.terraform.io/docs/providers/aws/r/instance.html&quot;&gt;EC2 instance&lt;/a&gt; and &lt;a href=&quot;https://www.terraform.io/docs/providers/aws/r/ecs_task_definition.html&quot;&gt;ECS task definition&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;terraform&quot;&gt;
resource &amp;quot;aws_instance&amp;quot; &amp;quot;ecs_host_instance&amp;quot; {
  iam_instance_profile = &amp;quot;${var.host_role_name}&amp;quot; // This is the Host Role, applied to the cluster instances. This is required to allow your host access to manage tasks.
}

resource &amp;quot;aws_ecs_task_definition&amp;quot; &amp;quot;ecs_task_definition&amp;quot; {
  execution_role_arn = &amp;quot;${var.task_execution_role_arn}&amp;quot; // This is the Task Execution Role, only required on Fargate. Called &amp;quot;ecsTaskExecutionRole&amp;quot; above.
  task_role_arn      = &amp;quot;${var.container_role_arn}&amp;quot; // This is the Task Role, or Container Role. This is required only if code running in your container needs access to AWS services.
}
&lt;/pre&gt;
&lt;h2&gt;Which IAM Role will my code run as?&lt;/h2&gt;
&lt;p&gt;Assuming your code is using a recent version of the AWS SDK with the default credentials provider chain, i.e. not explicitly specifying where credentials are coming from, it will first attempt to get credentials from the &lt;i&gt;ECS Task Role&lt;/i&gt;. If that fails, it will fall back to the &lt;i&gt;Host Role&lt;/i&gt;.&lt;/p&gt;
&lt;p&gt;Note: Certain versions of Hadoop and services running on top of it like Flume, for example, will pull in the &lt;i&gt;Host Role&lt;/i&gt; no matter what. If, like on Fargate, there is no Host Role, Flume will not be able to find credentials.&lt;/p&gt;
&lt;h3&gt;Sources:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://serverfault.com/questions/854413/confused-by-the-role-requirement-of-ecs/854467#854467&quot;&gt;https://serverfault.com/questions/854413/confused-by-the-role-requirement-of-ecs/854467#854467&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_execution_IAM_role.html&quot;&gt;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_execution_IAM_role.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/instance_IAM_role.html&quot;&gt;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/instance_IAM_role.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Cox-Automotive/terraform-provider-alks/blob/master/README.md&quot;&gt;https://github.com/Cox-Automotive/terraform-provider-alks/blob/master/README.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="aws ecs docker iam role task execution containers terraform" /></entry></feed>